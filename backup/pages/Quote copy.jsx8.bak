import React, { useState, useEffect } from 'react'
import { useLocation } from 'react-router-dom'
import { SimplePageLayout } from '../layouts'
import { SimpleTable, StatusBadge, CurrencyFormat, DateFormat, ExpiryStatus, ActionButtonGroup, ActionButtonPresets, TableCell } from '../components'
import { quotesAPI } from '../utils/apiClient'

const Quote = () => {
  const location = useLocation()
  const [quotes, setQuotes] = useState([])
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [filterStatus, setFilterStatus] = useState('active') // Default kepada active
  const [showHistory, setShowHistory] = useState(false) // Toggle untuk sejarah
  const [actionLoading, setActionLoading] = useState({})

  // Function to calculate days until expiry
  const calculateDaysUntilExpiry = (validUntil) => {
    if (!validUntil) return 0
    const today = new Date()
    const validDate = new Date(validUntil)
    const diffTime = validDate - today
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
    return diffDays
  }

  // Function to handle quote status change
  const handleQuoteStatusChange = async (quoteId, action) => {
    // Confirmation dialog to prevent accidental clicks
    const actionText = action === 'accept' ? 'accept' : action === 'reject' ? 'reject' : 'mark as dummy'
    const confirmMessage = `Are you sure you want to ${actionText} this quote?`
    
    if (!window.confirm(confirmMessage)) {
      return // User cancelled, exit function
    }

    try {
      setActionLoading(prev => ({ ...prev, [quoteId]: true }))
      
      const statusMap = { 'accept': 'ACCEPTED', 'reject': 'REJECTED', 'dummy': 'DUMMY' }
      const response = await quotesAPI.updateStatus(quoteId, statusMap[action] || action.toUpperCase())

      if (response?.success) {
        const newStatus = action === 'accept' ? 'accepted' : action === 'reject' ? 'rejected' : action.toLowerCase()
        setQuotes(prev => prev.map(quote => quote.id === quoteId ? { ...quote, status: newStatus } : quote))
        // alert(`Quote ${actionText}ed successfully!`)
      } else {
        const errorMessage = response?.message || response?.error || 'Unknown error'
        const statusMessages = { 400: `Invalid request: ${errorMessage}`, 404: 'Quote not found', 500: `Server error: ${errorMessage}` }
        // alert(statusMessages[response?.status] || `Failed to ${action} quote: ${errorMessage}`)
      }
    } catch (error) {
      // alert(`Error ${action}ing quote: ${error.message}`)
      console.error(`Error ${action}ing quote: ${error.message}`)
    } finally {
      setActionLoading(prev => ({ ...prev, [quoteId]: false }))
    }
  }

  // Function to fetch quotes
  const fetchQuotes = async () => {
    try {
      setLoading(true)
      const response = await quotesAPI.getAll()
      
      if (response?.success) {
        setQuotes(response.data.quotes.map(quote => ({
          id: quote.id,
          quoteNumber: quote.quoteNumber,
          customerName: quote.customer?.name || 'N/A',
          amount: parseFloat(quote.total),
          status: quote.status.toLowerCase(),
          date: quote.date,
          validUntil: quote.validUntil,
          subject: quote.subject || 'N/A'
        })))
      } else {
        throw new Error('API response not successful')
      }
    } catch (error) {
      setQuotes([])
    } finally {
      setLoading(false)
    }
  }

  // Fetch quotes from API
  useEffect(() => {
    fetchQuotes()
  }, [])

  // Refresh data when location changes (e.g., after edit)
  useEffect(() => {
    if (location.state?.refresh) fetchQuotes()
  }, [location])

  const filteredQuotes = quotes.filter(quote => {
    const matchesSearch = quote.quoteNumber.toLowerCase().includes(searchTerm.toLowerCase()) ||
      quote.customerName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      quote.subject.toLowerCase().includes(searchTerm.toLowerCase())
    
    if (filterStatus === 'all') return matchesSearch
    if (filterStatus === 'active') return matchesSearch && (quote.status === 'draft' || quote.status === 'sent')
    if (filterStatus === 'accepted') return matchesSearch && quote.status === 'accepted'
    if (filterStatus === 'rejected') return matchesSearch && quote.status === 'rejected'
    if (filterStatus === 'dummy') return matchesSearch && quote.status === 'dummy'
    return matchesSearch
  })
  // Table columns configuration
  const columns = [
      {
        key: 'quoteNumber',
        header: 'Quote No.',
        headerClassName: 'text-center',
        cellClassName: 'text-center text-sm',
        render: (value) => <TableCell value={value} className="font-medium text-gray-900" />
      },
      {
        key: 'customerName',
        header: 'Customer',
        render: (value) => <TableCell value={value} className="text-sm text-gray-900" title={value} />
      },
      {
        key: 'subject',
        header: 'Subject',
        render: (value) => <TableCell value={value} className="text-sm text-gray-600" title={value} />
      },
      {
        key: 'amount',
        header: 'Amount',
        headerClassName: 'text-right',
        cellClassName: 'text-right font-semibold',
        render: (value) => <CurrencyFormat amount={value} />
      },
      {
        key: 'status',
        header: 'Status',
        headerClassName: 'text-center',
        cellClassName: 'text-center',
        render: (value) => <StatusBadge status={value} />
      },
      {
        key: 'date',
        header: 'Date',
        headerClassName: 'text-center',
        cellClassName: 'text-center text-sm',
        render: (value) => <DateFormat date={value} />
      },
    {
      key: 'validUntil',
      header: 'Validity',
      headerClassName: 'text-center',
      cellClassName: 'text-center text-sm font-medium',
      render: (value, row) => (
        <ExpiryStatus 
          validUntil={value} 
          status={row.status} 
          calculateDaysUntilExpiry={calculateDaysUntilExpiry} 
        />
      )
    },
    {
      key: 'actions',
      header: 'Quick Actions',
      headerClassName: 'text-center',
      cellClassName: 'text-center',
      render: (value, row) => (
        <div className="flex items-center justify-center">
          {(row.status === 'draft' || row.status === 'sent') && (
            <ActionButtonGroup
              data={row}
              {...ActionButtonPresets.quote}
              loading={{ approve: actionLoading[row.id], reject: actionLoading[row.id], dummy: actionLoading[row.id] }}
              onApprove={() => handleQuoteStatusChange(row.id, 'accept')}
              onReject={() => handleQuoteStatusChange(row.id, 'reject')}
              onDummy={() => handleQuoteStatusChange(row.id, 'dummy')}
              size="sm"
            />
          )}
        </div>
      )
    }
  ]
  return (
    <SimplePageLayout
      title="QUOTE MANAGEMENT"
      newButtonText="+ CREATE NEW QUOTE"
      onNewClick={() => window.location.href = '/quotes/new'}
      buttonColor="green"
      filterOptions={["ALL", "ACTIVE", "DUMMY", "ACCEPTED", "REJECTED"]}
      activeFilter={{ 'all': 'ALL', 'active': 'ACTIVE', 'accepted': 'ACCEPTED', 'rejected': 'REJECTED', 'dummy': 'DUMMY' }[filterStatus] || 'ALL'}
      onFilterChange={(filter) => {
        const statusMap = { 'ALL': 'all', 'ACTIVE': 'active', 'DUMMY': 'dummy', 'ACCEPTED': 'accepted', 'REJECTED': 'rejected' }
        setFilterStatus(statusMap[filter] || 'all')
      }}
      onRefresh={fetchQuotes}
    >
      <SimpleTable
        data={filteredQuotes}
        columns={columns}
        loading={loading}
        onEdit={(row) => window.location.href = `/quotes/${row.id}/edit`}
        onDuplicate={(row) => {/* TODO: Implement duplicate quote functionality */}}
        onDelete={(row) => {/* TODO: Implement delete quote functionality */}}
        hideActionsForStatus={['accepted', 'rejected', 'dummy']}
      />
    </SimplePageLayout>
  )
}

export default Quote